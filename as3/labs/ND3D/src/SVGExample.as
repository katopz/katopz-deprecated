package{	import com.zavoo.svg.SvgPath;		import de.nulldesign.nd3d.view.AbstractView;		import flash.display.Graphics;	import flash.display.Sprite;	import flash.events.Event;	import flash.utils.ByteArray;		import net.hires.debug.Stats;	[SWF(backgroundColor="#FFFFFF", frameRate="30", quality="MEDIUM", width="800", height="600")]	public class SVGExample extends AbstractView	{		private var paths:Array = [];		private var canvas:Sprite;				[Embed(source="assets/thai2.txt", mimeType="application/octet-stream")]		private var ThaiSVG:Class;				public function SVGExample()		{			canvas = new Sprite();			addChild(canvas);						super(canvas, 800, 600);						/*			var s:Sphere = new Sphere(20, 100, new PixelMaterial(0xFF0000, 1, 2));			s.xPos = -100;			renderList.push(s);			*/						var _data:ByteArray = new ThaiSVG() as ByteArray;			var str:* = _data.readUTFBytes(_data.length); 						getPaths(str);			drawPathsTo(canvas.graphics, .5);						createDebugAxis();			addChild(new Stats());		}				public function getPaths(svgData:String):void		{			var pathTagRE:RegExp = /(<path.*?\/>)/sig;		    var pathArray:Array;		    while(pathArray = pathTagRE.exec(svgData))		    	paths.push(new SvgPath(pathArray[1]));		}		/*		override protected function loop(e:Event):void		{			super.loop(e);			canvas.rotationY++		}		*/		public function drawPathsTo(grahics:Graphics, scale :Number = 1, offsetX:Number = 0, offsetY:Number = 100) : void 		{			for each(var path:SvgPath in paths)			{				grahics.beginFill(path.fill, path.fillAlpha);				grahics.lineStyle(path.strokeWidth,path.stroke,path.strokeAlpha);					var _path_d:Array = path.d;				for each(var line:Array in _path_d)				{					var _line_1:Array = line[1];					if(_line_1[1]>0)					switch(line[0])					{						case "M":							grahics.moveTo							(								Number(_line_1[0]) * scale + offsetX, Number(_line_1[1]) * scale + offsetY							);							break;													case "L":							grahics.lineTo							(								Number(_line_1[0]) * scale + offsetX, Number(_line_1[1]) * scale + offsetY							);							break;													case "C":							/*							grahics.lineTo							(								Number(_line_1[0]) * scale + offsetX, Number(_line_1[1]) * scale + offsetY							);							grahics.lineTo							(								Number(_line_1[2]) * scale + offsetX, Number(_line_1[3]) * scale + offsetY							);							*/							grahics.curveTo							(								Number(_line_1[0]) * scale + offsetX, uint(_line_1[1]) * scale + offsetY, 								Number(_line_1[2]) * scale + offsetX, uint(_line_1[3]) * scale + offsetY							);							break;					}					grahics.endFill();				}							}		}	}}