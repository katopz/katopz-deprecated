<languageVersion : 1.0;>
/* 
 * $Id: MergeExchangeSort.pbk 69 2008-11-17 06:19:20Z danielr $
 * 
 * Copyright (c) 2008 Daniel Rinehart
 * http://danielr.neophi.com/
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
kernel MergeExchangeSort
<   namespace : "Daniel Rinehart";
vendor : "NeoPhi.com";
version : 1;
description : "Merge-Exchange Sorting (Batcher's Method)";
>
{
    input image4 src;
    input image4 book;
    output pixel4 dst;

    void
    evaluatePixel()
    {
        // grab the data to figure out what which direction to compare with, if any
        pixel4 bookdata = sampleNearest(book, outCoord());
        // grab the d value to use, which is always stored at x = 0 for this row
        pixel4 dData = sampleNearest(book, float2(0.0, outCoord().y));
        // convert it into a real value, only need GB since we would create images too large otherwise
        // although I don't know what the size limit is...
        float d = dData.g * 65536.0 + dData.b * 256.0;
        // grab the previous step's data, doing this makes for easier pipelining
        pixel4 me = sampleNearest(src, outCoord() + float2(0.0, -1.0));
        // default to doing nothing
        dst = me;
        // always skip x = 0 as that holds bookkeeping information
        // and skip y = 0 as that is the start of the pipeline
        // we read the previous row and write in this row
        if ((int(outCoord().x) != 0) && (int(outCoord().y) != 0))
        {
            // need to compare to the value on our right at me.x + d
            if (bookdata.r == 1.0)
            {
                pixel4 right = sampleNearest(src, outCoord() + float2(d, -1.0));
                // simplistic way to make the RGB compare like a number, can probably be optimized
                if ((me.r > right.r) || ((me.r == right.r) && ((me.g > right.g) || ((me.g == right.g) && (me.b > right.b)))))
                {
                    dst = right;
                }
            }
            // need compare to the value on our left at me.x - d
            else if (bookdata.g == 1.0)
            {
                pixel4 left = sampleNearest(src, outCoord() + float2(-d, -1.0));
                // see note above
                if ((left.r > me.r) || ((left.r == me.r) && ((left.g > me.g) || ((left.g == me.g) && (left.b > me.b)))))
                {
                    dst = left;
                }
            }
        }
     }
}
