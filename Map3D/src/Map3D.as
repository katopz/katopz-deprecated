package{	import __AS3__.vec.Vector;		import com.zavoo.svg.SvgPath;		import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.display.Sprite;	import flash.events.Event;	import flash.utils.ByteArray;		import net.hires.debug.Stats;	[SWF(backgroundColor="#000000", frameRate="30", quality="MEDIUM", width="800", height="600")]	public class Map3D extends Sprite	{		// data		[Embed(source="assets/n.txt", mimeType="application/octet-stream")]		private var ThaiSVG:Class;		private var pathTagRE:RegExp = /(<path.*?\/>)/sig;		private var pathArray:Array;		private var svgData:String;		private var paths:Array = [];				// layer		private var canvas:Sprite;		private var _time:Number;				// bmp		private var _roadBitmap:Bitmap;		private var _roadBitmapData:BitmapData;				private var _trafficBitmap:Bitmap;		private var _trafficBitmapData:BitmapData;				private var _trafficCanvas:Sprite;				// color		private var color:Number = 0xFFFFCC00;				public function Map3D()		{			// setup canvas			_roadBitmapData = new BitmapData(300,370, true,0x00000000);			_roadBitmap = new Bitmap(_roadBitmapData);			addChild(_roadBitmap);						/*			_trafficBitmapData = new BitmapData(300,370, true,0x00000000);			_trafficBitmap = new Bitmap(_trafficBitmapData);			addChild(_trafficBitmap);			*/						_trafficCanvas = new Sprite();			addChild(_trafficCanvas);						// setup data			var _data:ByteArray = new ThaiSVG() as ByteArray;			svgData = _data.readUTFBytes(_data.length); 						// process			_vertices = new Vector.<Vertex2D>();			addEventListener(Event.ENTER_FRAME, processData);						addChild(new Stats());		}				private function processData(e:Event):void		{			pathArray = pathTagRE.exec(svgData);			if (pathArray)			{				var _path:SvgPath = new SvgPath(pathArray[1]);				setPixelSVG(_path, _roadBitmapData);				paths.push(_path);			}			else			{				removeEventListener(Event.ENTER_FRAME, processData);				_vertices.fixed = true;				addEventListener(Event.ENTER_FRAME, drawData);								addEventListener(Event.ENTER_FRAME, drawPath);			}		}				private function drawData(e:Event):void		{			if(i<_vertices.length)			{				setPixel(100);				i+=100;			}else{				removeEventListener(Event.ENTER_FRAME, drawData);			}		}				private function drawPath(e:Event):void		{			if(j<_vertices.length)			{				setPath(10);				j+=10;			}else{				removeEventListener(Event.ENTER_FRAME, drawData);			}		}				private function setPath(step:int):void		{				var _vertex2D:Vertex2D;			var _length:int = _vertices.length;						if(i+step>_length)				return;						//_trafficCanvas.graphics.beginFill(0xFFFFFF);			_trafficCanvas.graphics.lineStyle(1, 0xFFFFFF, 1);			_trafficCanvas.graphics.moveTo(_vertices[i+step].x, _vertices[i+step].y);			do			{				if(i+step<_length)					_trafficCanvas.graphics.lineTo(_vertices[i+step].x, _vertices[i+step].y);							}while(step-->0);			_trafficCanvas.graphics.endFill();		}					private function setPixel(step:int):void		{			_roadBitmapData.lock();			var _vertex2D:Vertex2D;			var _length:int = _vertices.length;			do{				if(i+step<_length)				{					_vertex2D =_vertices[i+step];					_roadBitmapData.setPixel32(_vertex2D.x, _vertex2D.y, color);				}			}while(step-->0);						_roadBitmapData.unlock();		}				private var i:int = 0;		private var j:int = 0;		private var _vertices:Vector.<Vertex2D>;				private function setPixelSVG(path:SvgPath, bitmapData:BitmapData, scale :Number = 1, offsetX:Number = 0, offsetY:Number = 0) : void 		{			//bitmapData.lock();			var _path_d:Array = path.d;			for each(var line:Array in _path_d)			{				var _line_1:Array = line[1];				if(_line_1[1]>0)					_vertices.push(new Vertex2D(int(_line_1[0]) * scale + offsetX, int(_line_1[1]) * scale + offsetY));									/*				switch(line[0])				{					case "M":						bitmapData.setPixel32						(							int(_line_1[0]) * scale + offsetX, int(_line_1[1]) * scale + offsetY, 							color						);					case "L":						bitmapData.setPixel32						(							int(_line_1[0]) * scale + offsetX, int(_line_1[1]) * scale + offsetY,							color						);						break;					case "C":						bitmapData.setPixel32						(							int(_line_1[0]) * scale + offsetX, int(_line_1[1]) * scale + offsetY, 							color						);						bitmapData.setPixel32						(							int(_line_1[2]) * scale + offsetX, int(_line_1[3]) * scale + offsetY,							color						);					break;				}			}			*/						//bitmapData.unlock();			}		}	}}