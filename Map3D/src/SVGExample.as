package{	import com.zavoo.svg.SvgPath;		import flash.display.Graphics;	import flash.display.Sprite;	import flash.events.Event;	import flash.utils.ByteArray;	import flash.utils.getTimer;		import net.hires.debug.Stats;	[SWF(backgroundColor="#000000", frameRate="30", quality="MEDIUM", width="800", height="600")]	public class SVGExample extends Sprite	{		// data		[Embed(source="assets/n.txt", mimeType="application/octet-stream")]		private var ThaiSVG:Class;		private var pathTagRE:RegExp = /(<path.*?\/>)/sig;		private var pathArray:Array;		private var svgData:String;		private var paths:Array = [];				// layer		private var canvas:Sprite;		private var _time:Number;				public function SVGExample()		{			// setup data			_time = getTimer();						var _data:ByteArray = new ThaiSVG() as ByteArray;			var str:* = _data.readUTFBytes(_data.length); 			getPaths(str);			trace(getTimer()-_time);						paint();		}				public function getPaths(svgData:String):void		{		    this.svgData = svgData;		    //addEventListener(Event.ENTER_FRAME, processData);		    while(pathArray = pathTagRE.exec(svgData))		    	paths.push(new SvgPath(pathArray[1]));		}				private function processData(e:Event):void		{			pathArray = pathTagRE.exec(svgData);			if (pathArray)			{				paths.push(new SvgPath(pathArray[1]));			}			else			{				removeEventListener(Event.ENTER_FRAME, processData);				paint();			}		}				private function paint():void		{			trace("paint");						canvas = new Sprite();			addChild(canvas);						//canvas.scrollRect = new Rectangle(0,0,100,100);			drawPathsTo(paths, canvas.graphics, .5);			trace(getTimer()-_time);						addChild(new Stats());		}				/*		override protected function loop(e:Event):void		{			super.loop(e);			canvas.rotationY++		}		*/				public function drawPathsTo(paths:Array, grahics:Graphics, scale :Number = 1, offsetX:Number = 0, offsetY:Number = 0) : void 		{			for each(var path:SvgPath in paths)			{				grahics.beginFill(path.fill, path.fillAlpha);				grahics.lineStyle(path.strokeWidth,path.stroke,path.strokeAlpha);					var _path_d:Array = path.d;				for each(var line:Array in _path_d)				{					var _line_1:Array = line[1];					if(_line_1[1]>0)					switch(line[0])					{						case "M":							grahics.moveTo							(								int(_line_1[0]) * scale + offsetX, int(_line_1[1]) * scale + offsetY							);							break;													case "L":							grahics.lineTo							(								int(_line_1[0]) * scale + offsetX, int(_line_1[1]) * scale + offsetY							);							break;													case "C":							/*							grahics.lineTo							(								Number(_line_1[0]) * scale + offsetX, Number(_line_1[1]) * scale + offsetY							);							grahics.lineTo							(								Number(_line_1[2]) * scale + offsetX, Number(_line_1[3]) * scale + offsetY							);							*/							grahics.curveTo							(								int(_line_1[0]) * scale + offsetX, int(_line_1[1]) * scale + offsetY, 								int(_line_1[2]) * scale + offsetX, int(_line_1[3]) * scale + offsetY							);							break;					}					grahics.endFill();				}							}		}	}}