package away3dlite.loaders{	import __AS3__.vec.Vector;		import away3dlite.animators.*;	import away3dlite.animators.frames.Frame;	import away3dlite.arcane;	import away3dlite.containers.ObjectContainer3D;	import away3dlite.core.base.Mesh;	import away3dlite.core.base.Object3D;		import flash.utils.ByteArray;	import flash.utils.Endian;	use namespace arcane;	public class MD2Builder extends AbstractParser	{        public static var md2:ByteArray;        private var ident:int;        private var version:int;        private var skinwidth:int;        private var skinheight:int;        private var framesize:int;        private var num_skins:int;        private var num_vertices:int;        private var num_st:int;        private var num_tris:int;        private var num_glcmds:int;        private var num_frames:int;        private var offset_skins:int;        private var offset_st:int;        private var offset_tris:int;        private var offset_frames:int;        private var offset_glcmds:int;        private var offset_end:int;    	private var mesh:MovieMesh;		private var vertices:Vector.<Number> = new Vector.<Number>();		private var minX:Number = Infinity, maxX:Number = -Infinity, minY:Number = Infinity, maxY:Number = -Infinity, minZ:Number = Infinity, maxZ:Number = -Infinity;		/** @private */		public function convert(object3D:Object3D, animationName:String = "default"):void		{			mesh._vertices.fixed = false;			mesh._uvtData.fixed = false;			mesh._indices.fixed = false;			mesh._faceLengths.fixed = false;			var _bonesAnimator:BonesAnimator = object3D.animationLibrary.getAnimation(animationName).animation as BonesAnimator;			_bonesAnimator.update(0);			var _inputMesh:Mesh = ObjectContainer3D(object3D).children[0] as Mesh;			mesh._vertices.length = _inputMesh._vertices.length;			mesh._uvtData.length = _inputMesh._uvtData.length;			mesh._indices.length = _inputMesh._indices.length;			mesh._faceLengths.length = _inputMesh._faceLengths.length;			var i:int = _inputMesh._vertices.length;			while (i--)				mesh._vertices[i] = _inputMesh._vertices[i];			i = _inputMesh._uvtData.length;			while (i--)				mesh._uvtData[i] = _inputMesh._uvtData[i];			i = _inputMesh._indices.length;			while (i--)				mesh._indices[i] = _inputMesh._indices[i];			i = _inputMesh._faceLengths.length;			while (i--)				mesh._faceLengths[i] = _inputMesh._faceLengths[i];			convertFrames(_inputMesh, _bonesAnimator);			// material			if (_inputMesh.material)				mesh.material = _inputMesh.material;			// build			mesh.buildFaces();		}				/** @private */		private function convertFrames(_inputMesh:Mesh, _bonesAnimator:BonesAnimator):void		{			var _length:Number = _bonesAnimator.length;			var _step:Number = mesh.fps/1000;			var i:Number;			for (i = 0; i < _length; i+=_step)			{				_bonesAnimator.update(i);				var frame:Frame = new Frame("walk__0", _inputMesh._vertices.concat());				mesh.addFrame(frame);			}		}				arcane override function prepareData(data:*):void		{			md2 = data as ByteArray;		}				/** @private */        private function exportData():void        {        	//md2 = new ByteArray();			var a:int, b:int, c:int, ta:int, tb:int, tc:int, i1:int, i2:int, i3:int;			var i:int, uvs:Array = [];						md2.position = 0;        	        	// Make sure to have this in Little Endian or you will hate you life.        	md2.endian = Endian.LITTLE_ENDIAN;        	        	// Write the header to make it valid MD2 file        	writeMD2Header(md2);        	        	// UV coordinates        	num_st = 3;        	skinwidth = 128;        	skinheight = 128;        	        	/* offset texture coordinate data */        	md2.position = offset_st = 132;        	        	//for (i = 0; i < num_st; i++)			{				md2.writeShort(skinwidth*1);				md2.writeShort(skinheight*1);								md2.writeShort(skinwidth*0);				md2.writeShort(skinheight*1);								md2.writeShort(skinwidth*0);				md2.writeShort(skinheight*0);			}        	        	//var _vertices:Vector.<Number> = Vector.<Number>([0.17374591901898384,59.80972157791257,-1.1772219319153288e-7,-0.06241645663976669,-0.16771076247096062,-1.848996226440358e-7,-60.0476598739624,-0.16771076247096062,-7.245044725615046e-8]);        	        	var _vertices:Vector.<Number> = Vector.<Number>([2, 1, 0]);        				//num_tris = mesh._vertices.length/9;			num_tris = 1;						// faces			md2.position = offset_tris = 144;						for (i = 0; i < num_tris; i++) 			{				i1 = i*3;				i2 = i1 + 1;				i3 = i1 + 2;								//collect indices				a = _vertices[i1]// = mesh._indices[i3];				b = _vertices[i2]// = mesh._indices[i2];				c = _vertices[i3]// = mesh._indices[i1];								md2.writeShort(a);				md2.writeShort(b);				md2.writeShort(c);								//collect uvData 				uvs[ta*2 + 0] = mesh._uvtData[i1*3 + 0];				uvs[ta*2 + 1] = mesh._uvtData[i1*3 + 1]								uvs[tb*2 + 0] = mesh._uvtData[i2*3 + 0];				uvs[tb*2 + 1] = mesh._uvtData[i2*3 + 1];								uvs[tc*2 + 0] = mesh._uvtData[i3*3 + 0];				uvs[tc*2 + 1] = mesh._uvtData[i3*3 + 1];								// where's ta,tb,tc cam from huh!?				md2.writeShort(ta=0);				md2.writeShort(tb=1);				md2.writeShort(tc=2);			}						md2.position = offset_frames = 156;						/*			// uvData			for (i = 0; i < mesh._uvtData.length/2; i++)			{				md2.writeShort(mesh._uvtData[i]);			}								md2.writeShort();				md2.writeShort();				md2.writeShort();								mesh._uvtData[i1*3 + 0] = uvs[ta*2];				mesh._uvtData[i1*3 + 1] = uvs[ta*2 + 1];				mesh._uvtData[i1*3 + 2] = 1;								mesh._uvtData[i2*3 + 0] = uvs[tb*2];				mesh._uvtData[i2*3 + 1] = uvs[tb*2 + 1];				mesh._uvtData[i2*3 + 2] = 1;								mesh._uvtData[i3*3 + 0] = uvs[tc*2];				mesh._uvtData[i3*3 + 1] = uvs[tc*2 + 1];				mesh._uvtData[i3*3 + 2] = 1;			}						// Frame animation data			//		This part is a little funky.			md2.position = offset_frames;			writeFrames(md2);                        //setup vertices for the first frame            i = mesh._vertices.length;            vertices = mesh.frames[0].vertices;			while (i--)				mesh._vertices[i] = vertices[i];						mesh.buildFaces();			*/        }        		private function writeMD2Header(data:ByteArray):void		{			//ident 			data.writeInt(844121161);			//version			data.writeInt(8);			//skinwidth 			data.writeInt(128);			//skinheight 			data.writeInt(128);			//framesize 			data.writeInt(52);			//num_skins 			data.writeInt(1);			//num_vertices 			data.writeInt(3);			//num_st /* number of texture coordinates */			data.writeInt(3);			//num_tris 			data.writeInt(1);			//num_glcmds 			data.writeInt(208);			//num_frames 			data.writeInt(1);			//offset_skins 			data.writeInt(68);			//offset_st /* offset texture coordinate data */			data.writeInt(132);			/*			offset_tris = data.writeInt();			offset_frames = data.writeInt();			offset_glcmds = data.writeInt();			offset_end = data.writeInt();			*/		}		public function export(object3D:Object3D = null):ByteArray		{			//convert(object3D);			exportData();			return md2;		}				public function MD2Builder()		{			// TODO : multi mesh			super();						mesh = (_container = new MovieMesh()) as MovieMesh;                        binary = true;		}		    	/**    	 * A scaling factor for all geometry in the model. Defaults to 1.    	 */        public var scaling:Number = 1;            	/**    	 * Controls the automatic centering of geometry data in the model, improving culling and the accuracy of bounding dimension values.    	 */        public var centerMeshes:Boolean;	}}