package away3dlite.loaders{	import __AS3__.vec.Vector;		import away3dlite.animators.*;	import away3dlite.animators.frames.Frame;	import away3dlite.arcane;	import away3dlite.containers.ObjectContainer3D;	import away3dlite.core.base.Mesh;	import away3dlite.core.base.Object3D;	import away3dlite.materials.BitmapMaterial;		import flash.geom.Vector3D;	import flash.utils.ByteArray;	import flash.utils.Endian;	use namespace arcane;	public class MD2Builder extends MD2	{		public static var _outMesh:MovieMesh;		/** @private */		public function convert(object3D:Object3D, animationName:String = "default"):MovieMesh		{			_outMesh = new MovieMesh();			_outMesh._vertices.fixed = false;			_outMesh._uvtData.fixed = false;			_outMesh._indices.fixed = false;			_outMesh._faceLengths.fixed = false;			if (object3D.animationLibrary)			{				var _bonesAnimator:BonesAnimator = object3D.animationLibrary.getAnimation(animationName).animation as BonesAnimator;				_bonesAnimator.update(0);				var _inputMesh:Mesh = ObjectContainer3D(object3D).children[0] as Mesh;				_outMesh._vertices = _inputMesh._vertices.concat();				_outMesh._uvtData = _inputMesh._uvtData.concat();				_outMesh._indices = _inputMesh._indices.concat();				_outMesh._faceLengths = _inputMesh._faceLengths.concat();				convertFrames(_inputMesh, _bonesAnimator);				// material				if (_inputMesh.material)					_outMesh.material = _inputMesh.material;				// build				_outMesh.buildFaces();			}			else			{				_outMesh = object3D as MovieMesh;			}			mesh = _outMesh;_outMesh = mesh;			return _outMesh;		}		/** @private */		private function convertFrames(_inputMesh:Mesh, _bonesAnimator:BonesAnimator):void		{			var _length:Number = _bonesAnimator.length;			var _step:Number = _outMesh.fps / 1000;			var i:Number;			for (i = 0; i < _length; i += _step)			{				_bonesAnimator.update(i);				var frame:Frame = new Frame("walk__0", _inputMesh._vertices.concat());				_outMesh.addFrame(frame);			}		}		arcane override function prepareData(data:*):void		{			super.prepareData(data);			//md2 = data as ByteArray;		}		/** @private */		private function exportData():void		{			md2 = new ByteArray();			var a:int, b:int, c:int, ta:int, tb:int, tc:int, i1:int, i2:int, i3:int;			var i:int, uvs:Array = [];			md2.position = 0;			// Make sure to have this in Little Endian or you will hate you life.			md2.endian = Endian.LITTLE_ENDIAN;			// Write the header to make it valid MD2 file			writeMD2Header(md2);			// UV coordinates			/* offset texture coordinate data */			md2.position = offset_st;			var _uvtData:Vector.<Number> = mesh._uvtData;			for (i = 0; i < _uvtData.length; i += 3)			{				md2.writeShort(skinwidth * _uvtData[i + 0]);				md2.writeShort(skinheight * _uvtData[i + 1]);			}			// faces			trace("_indices:(" + mesh._indices.length + "):\t\t" + mesh._indices);			ta = 0;			tb = 1;			tc = 2;			md2.position = offset_tris;			for (i = 0; i < num_tris; i++)			{				i1 = i * 3 + 0;				i2 = i * 3 + 1;				i3 = i * 3 + 2;				//collect indices				a = mesh._indices[i1];				b = mesh._indices[i2];				c = mesh._indices[i3];				md2.writeShort(a);				md2.writeShort(b);				md2.writeShort(c);				//collect uvData 				uvs[ta * 2 + 0] = _uvtData[i1 * 3 + 0];				uvs[ta * 2 + 1] = _uvtData[i1 * 3 + 1];				uvs[tb * 2 + 0] = _uvtData[i2 * 3 + 0];				uvs[tb * 2 + 1] = _uvtData[i2 * 3 + 1];				uvs[tc * 2 + 0] = _uvtData[i3 * 3 + 0];				uvs[tc * 2 + 1] = _uvtData[i3 * 3 + 1];				// where's ta,tb,tc cam from huh!?				md2.writeShort(ta);				md2.writeShort(tb);				md2.writeShort(tc);				//trace(ta, tb, tc);				ta += 3;				tb += 3;				tc += 3;			}			md2.position = offset_frames;			writeFrames(md2);			//mesh.buildFaces();		}		private function writeFrames(data:ByteArray):void		{			var sx:Number, sy:Number, sz:Number;			var tx:Number, ty:Number, tz:Number;			var fvertices:Vector.<Number>, frame:Frame;			var tvertices:Vector.<Number>;			var tvertices0:Vector.<Number>;			var i:int, j:int, k:int, char:int;			//TODOnum_frames = 1;			for (i = 0; i < num_frames; i++)			{				frame = mesh.frames[i];				tvertices = new Vector.<Number>(num_vertices * 3, true);				//tvertices0 = new Vector.<Number>(num_vertices*3, true);				fvertices = frame.vertices; //new Vector.<Number>(num_tris*9, true);fvertices = mesh.vertices;				//0.04723247513175011,0.047226324677467346,-1.4603789011413681e-10,				//-12.00953197479248,-0.03354215249419212,-3.233832993054797e-11				/*				   //plane2_weld.md2				   data.writeFloat(sx=0.062745101749897);				   data.writeFloat(sy=0.125490203499794);				   data.writeFloat(sz=-1.6812485847950143e-9);				   data.writeFloat(tx=-16);				   data.writeFloat(ty=4.3590597442744183e-7);				   data.writeFloat(tz=-1.1680054947044768e-14);				 */				/*				   //plane				   data.writeFloat(sx=0.04723247513175011);				   data.writeFloat(sy=0.047226324677467346);				   data.writeFloat(sz=-1.4603789011413681e-10);				   data.writeFloat(tx=-12.00953197479248);				   data.writeFloat(ty=-0.03354215249419212);				   data.writeFloat(tz=-3.233832993054797e-11);				 */				/*				   //cube				   data.writeFloat(sx=0.062745101749897);				   data.writeFloat(sy=0.062745101749897);				   data.writeFloat(sz=0.062745101749897);				   data.writeFloat(tx=-16);				   data.writeFloat(ty=2.1435917574308405e-7);				   data.writeFloat(tz=-8);				   */				/*						//cube_uv	   				data.writeFloat(sx = 0.03931807726621628);				data.writeFloat(sy = 0.03966912999749184);				data.writeFloat(sz = 0.044583890587091446);				data.writeFloat(tx = 0.2463519126176834);				data.writeFloat(ty = -10.381439208984375);				data.writeFloat(tz = 0.07072663307189941); 				*/				for (j = 0; j < num_tris*3; j++) 				{					//collect min/max for scale					minX = (fvertices[j*3+0]<minX)?fvertices[j*3+0]:minX;					minY = (fvertices[j*3+1]<minY)?fvertices[j*3+1]:minY;					minZ = (fvertices[j*3+2]<minZ)?fvertices[j*3+2]:minZ;					maxX = (fvertices[j*3+0]>maxX)?fvertices[j*3+0]:maxX;					maxY = (fvertices[j*3+1]>maxY)?fvertices[j*3+1]:maxY;					maxZ = (fvertices[j*3+2]>maxZ)?fvertices[j*3+2]:maxZ;				}				var _vmin:Vector3D = new Vector3D(minX, minY, minZ);				var _vmax:Vector3D = new Vector3D(maxX, maxY, maxZ);				var _scale:Vector3D = _vmax.clone();				_scale.decrementBy(_vmin);				_scale.scaleBy(1/255);								data.writeFloat(sx = _scale.x);				data.writeFloat(sy = _scale.y);				data.writeFloat(sz = _scale.z);				data.writeFloat(tx = _vmin.x);				data.writeFloat(ty = _vmin.y);				data.writeFloat(tz = _vmin.z);				//write frame name				data.writeUTFBytes("Frame000");				//skip?				//offset_frames				data.position = offset_frames + 40;				fvertices = mesh.vertices;				trace("fvertices(" + fvertices.length + "):\t\t" + fvertices);				// read vertices				for (j = 0; j < num_tris * 3; j++)				{					tvertices[mesh._indices[j] * 3 + 0] = fvertices[j * 3 + 0];					tvertices[mesh._indices[j] * 3 + 1] = fvertices[j * 3 + 1];					tvertices[mesh._indices[j] * 3 + 2] = fvertices[j * 3 + 2];				}				trace("tvertices(" + tvertices.length + "):\t\t" + tvertices);				// Note, the extra data.position++ in the for loop is there 				// to skip over a byte that holds the "vertex normal index"				var _ss:Array = [];				var _a:Number, _b:Number, _c:Number;				k = 0;				for (j = 0; j < num_vertices; j++)				{					_a = tvertices[k++] / scaling;					_a = _a - tx;					_a = _a / sx;					_b = tvertices[k++] / scaling;					_b = _b - ty;					_b = _b / sy;					_c = tvertices[k++] / scaling;					_c = _c - tz;					_c = _c / sz;					data.writeByte(_a);					data.writeByte(_b);					data.writeByte(_c);					data.position++;					// for debug					_ss.push((_a), (_b), (_c));				}				trace("raw(" + _ss.length + "):\t\t" + _ss);			}		}		private function writeMD2Header(data:ByteArray):void		{			//CONST//ident 			data.writeInt(844121161);			//CONST//version			data.writeInt(8);			//skinwidth 			data.writeInt(skinwidth = BitmapMaterial(material).width);			//skinheight 			data.writeInt(skinheight = BitmapMaterial(material).height);			//framesize 0x34(52), 0x44(68) 			//vertnum = model.framelist[1].vlist.count			//framesize = 40+(4*vertnum)			// tri = 52, tri2 = 64, plane = 56, cube = 72			num_vertices = mesh._vertices.length / 3			data.writeInt(framesize = 40 + 4 * num_vertices);			//TODO:get from mat lib			//num_skins 			data.writeInt(num_skins = 1);			//num_vertices 			data.writeInt(num_vertices);			//num_st /* number of texture coordinates */			data.writeInt(num_st = mesh.faces.length * 3);			//num_tris 			data.writeInt(num_tris = mesh.faces.length);			//CONST//num_glcmds 			data.writeInt(num_glcmds = 0);			//num_frames 			data.writeInt(num_frames = 1);			//CONST//offset_skins = headersize			data.writeInt(offset_skins = 0x44);			//offset_st /* offset texture coordinate data */			//offset_st = offsetskins + (skinnum*64)			//0x84 			data.writeInt(offset_st = offset_skins + num_skins * 64);			//offsettris = offset_st + (texnum*texsize)			// 0x90, 144			data.writeInt(offset_tris = offset_st + num_st * 4);			// offsetframes = offsettris + (trinum*trisize)			// 0x9C, cube = 0x1A4 (420)			data.writeInt(offset_frames = offset_tris + num_tris * 12);			// offsetgl = offsetframes + (framenum*framesize)			// framesize = 40+(4*vertnum)			// 0xD0			data.writeInt(offset_glcmds = offset_frames + num_frames * framesize);			// offsetend = offsetgl + (glnum*4)			// 0xFC			data.writeInt(offset_end = offset_glcmds + num_glcmds * 4);		}		public function export(object3D:Object3D = null):ByteArray		{			//convert(object3D);			exportData();			return md2;		}		public function MD2Builder()		{			// TODO : multi mesh			super();			///binary = true;		}	}}