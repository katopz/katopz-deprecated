package away3dlite.loaders{	import __AS3__.vec.Vector;		import away3dlite.animators.*;	import away3dlite.animators.frames.Frame;	import away3dlite.arcane;	import away3dlite.containers.ObjectContainer3D;	import away3dlite.core.base.Mesh;	import away3dlite.core.base.Object3D;	import away3dlite.materials.BitmapMaterial;		import flash.utils.ByteArray;	import flash.utils.Endian;	use namespace arcane;	public class MD2Builder extends MD2	{        /*        private var md2:ByteArray;        private var ident:int;        private var version:int;        private var skinwidth:int;        private var skinheight:int;        private var framesize:int;        private var num_skins:int;        private var num_vertices:int;        private var num_st:int;        private var num_tris:int;        private var num_glcmds:int;        private var num_frames:int;        private var offset_skins:int;        private var offset_st:int;        private var offset_tris:int;        private var offset_frames:int;        private var offset_glcmds:int;        private var offset_end:int;    	private var mesh:MovieMesh;    	    	private var _outMesh:MovieMesh;    			// temporary use		private var _vertexIndices:Vector.<int> = new Vector.<int>();		private var _vertices:Vector.<Number> = new Vector.<Number>();				private var minX:Number = Infinity, maxX:Number = -Infinity, minY:Number = Infinity, maxY:Number = -Infinity, minZ:Number = Infinity, maxZ:Number = -Infinity;		*/				public static var _outMesh:MovieMesh;				/** @private */		public function convert(object3D:Object3D, animationName:String = "default"):void		{			_outMesh = new MovieMesh();						_outMesh._vertices.fixed = false;			_outMesh._uvtData.fixed = false;			_outMesh._indices.fixed = false;			_outMesh._faceLengths.fixed = false;			if(object3D.animationLibrary)			{				var _bonesAnimator:BonesAnimator = object3D.animationLibrary.getAnimation(animationName).animation as BonesAnimator;				_bonesAnimator.update(0);					var _inputMesh:Mesh = ObjectContainer3D(object3D).children[0] as Mesh;					_outMesh._vertices = _inputMesh._vertices.concat();				_outMesh._uvtData = _inputMesh._uvtData.concat();				_outMesh._indices = _inputMesh._indices.concat();				_outMesh._faceLengths = _inputMesh._faceLengths.concat();								convertFrames(_inputMesh, _bonesAnimator);					// material				if (_inputMesh.material)					_outMesh.material = _inputMesh.material;					// build				_outMesh.buildFaces();			}else{				_outMesh = object3D as MovieMesh;			}		}				/** @private */		private function convertFrames(_inputMesh:Mesh, _bonesAnimator:BonesAnimator):void		{			var _length:Number = _bonesAnimator.length;			var _step:Number = _outMesh.fps/1000;			var i:Number;			for (i = 0; i < _length; i+=_step)			{				_bonesAnimator.update(i);				var frame:Frame = new Frame("walk__0", _inputMesh._vertices.concat());				_outMesh.addFrame(frame);			}		}				arcane override function prepareData(data:*):void		{			super.prepareData(data);			//md2 = data as ByteArray;		}				/** @private */        private function exportData():void        {        	//md2 = new ByteArray();			var a:int, b:int, c:int, ta:int, tb:int, tc:int, i1:int, i2:int, i3:int;			var i:int, uvs:Array = [];						md2.position = 0;        	        	// Make sure to have this in Little Endian or you will hate you life.        	md2.endian = Endian.LITTLE_ENDIAN;        	        	// Write the header to make it valid MD2 file        	writeMD2Header(md2);        	        	// UV coordinates        	//TODO:tri2        	/* offset texture coordinate data */        	md2.position = offset_st;        	        	var _uvtData:Vector.<Number> = mesh._uvtData;        	        	for (i = 0; i < _uvtData.length; i+=3)			{				md2.writeShort(skinwidth*_uvtData[i + 0]);				md2.writeShort(skinheight*_uvtData[i + 1]);			}						// faces			//_vertexIndices = new Vector.<int>(mesh._indices.length);						trace("_indices:("+mesh._indices.length+"):\t\t"+mesh._indices);						//trace("_uvtData:("+_uvtData.length+"):"+_uvtData);						/*			tvertices = new Vector.<Number>();			for (var _vIndex:int = 0; _vIndex < ; _vIndex++) 			{				tvertices[_vertexIndices[j]*3 + 0] = mesh.vertices[j*3 + 0];				tvertices[_vertexIndices[j]*3 + 1] = mesh.vertices[j*3 + 1];				tvertices[_vertexIndices[j]*3 + 2] = mesh.vertices[j*3 + 2];			}			*/							ta = 0;			tb = 1;			tc = 2;						md2.position = offset_tris;			for (i = 0; i < num_tris; i++) 			{				i1 = i*3 + 0;				i2 = i*3 + 1;				i3 = i*3 + 2;								//collect indices				a = mesh._indices[i1];				b = mesh._indices[i2];				c = mesh._indices[i3];								md2.writeShort(a);				md2.writeShort(b);				md2.writeShort(c);								//collect uvData 				uvs[ta*2 + 0] = _uvtData[i1*3 + 0];				uvs[ta*2 + 1] = _uvtData[i1*3 + 1];								uvs[tb*2 + 0] = _uvtData[i2*3 + 0];				uvs[tb*2 + 1] = _uvtData[i2*3 + 1];								uvs[tc*2 + 0] = _uvtData[i3*3 + 0];				uvs[tc*2 + 1] = _uvtData[i3*3 + 1];								// where's ta,tb,tc cam from huh!?				md2.writeShort(ta);				md2.writeShort(tb);				md2.writeShort(tc);								//trace(ta, tb, tc);								ta += 3;				tb += 3;				tc += 3;			}						md2.position = offset_frames;			writeFrames(md2);						//mesh.buildFaces();        }                private function writeFrames(data:ByteArray):void		{			var sx:Number, sy:Number, sz:Number;			var tx:Number, ty:Number, tz:Number;			var fvertices:Vector.<Number>, frame:Frame;			var tvertices:Vector.<Number>;			var tvertices0:Vector.<Number>;			var i:int, j:int, k:int, char:int;						//TODO			//num_frames = 1;						for (i = 0; i < num_frames; i++) 			{				frame = mesh.frames[i];								tvertices = new Vector.<Number>(num_vertices*3, true);				//tvertices0 = new Vector.<Number>(num_vertices*3, true);				fvertices = frame.vertices; //new Vector.<Number>(num_tris*9, true);								//0.04723247513175011,0.047226324677467346,-1.4603789011413681e-10,				//-12.00953197479248,-0.03354215249419212,-3.233832993054797e-11				/*				//plane2_weld.md2				data.writeFloat(sx=0.062745101749897);				data.writeFloat(sy=0.125490203499794);				data.writeFloat(sz=-1.6812485847950143e-9);				data.writeFloat(tx=-16);				data.writeFloat(ty=4.3590597442744183e-7);				data.writeFloat(tz=-1.1680054947044768e-14);				*/								/*				//plane				data.writeFloat(sx=0.04723247513175011);				data.writeFloat(sy=0.047226324677467346);				data.writeFloat(sz=-1.4603789011413681e-10);				data.writeFloat(tx=-12.00953197479248);				data.writeFloat(ty=-0.03354215249419212);				data.writeFloat(tz=-3.233832993054797e-11);				*/								//cube				data.writeFloat(sx=0.062745101749897);				data.writeFloat(sy=0.062745101749897);				data.writeFloat(sz=0.062745101749897);				data.writeFloat(tx=-16);				data.writeFloat(ty=2.1435917574308405e-7);				data.writeFloat(tz=-8);								/*				data.writeFloat(sx=1);				data.writeFloat(sy=1);				data.writeFloat(sz=1);				data.writeFloat(tx=0);				data.writeFloat(ty=0);				data.writeFloat(tz=0);				*/								//write frame name				data.writeUTFBytes("Frame000");								//skip?				//offset_frames				data.position = offset_frames + 40;												fvertices = mesh.vertices;				trace("fvertices("+fvertices.length+"):\t\t"+fvertices);								//TODO:_vertexIndices				// read vertices				for (j = 0; j < num_tris*3; j++) 				{					tvertices[mesh._indices[j]*3 + 0] = fvertices[j*3 + 0]; 					tvertices[mesh._indices[j]*3 + 1] = fvertices[j*3 + 1];					tvertices[mesh._indices[j]*3 + 2] = fvertices[j*3 + 2];					/*trace					(						j*3 + 0,						j*3 + 1,						j*3 + 2					)					/*					trace					(						mesh._indices[j]*3 + 0,						mesh._indices[j]*3 + 1,						mesh._indices[j]*3 + 2					)					trace("-------------------")					*/				}				/*				trace("tvertices0("+tvertices0.length+"):\t\t"+tvertices0);				var _index:int = 0;				for (j = 0; j < 12; j++)				{					tvertices[j] = NaN;				}								for (j = 0; j < tvertices0.length; j+=3)				{					//trace(fvertices[j + 0], fvertices[j + 1], fvertices[j + 2])					for (i = 0; i < tvertices.length; i+=3)					{						if( isNaN(tvertices[i])||(							tvertices[i + 0] != fvertices[j + 0] &&							tvertices[i + 1] != fvertices[j + 1] &&							tvertices[i + 2] != fvertices[j + 2]))							{								tvertices[i + 0] = fvertices[j + 0];								tvertices[i + 1] = fvertices[j + 1];								tvertices[i + 2] = fvertices[j + 2];								//trace("++++", tvertices[i + 0], tvertices[i + 1], tvertices[i + 2]);								trace(i/3);								i = tvertices.length;																//_index +=3;								//j+=3;							}else if (							tvertices[i + 0] == fvertices[j + 0] &&							tvertices[i + 1] == fvertices[j + 1] &&							tvertices[i + 2] == fvertices[j + 2]){								trace(i/3);								i = tvertices.length;							}					}				}				*/				trace("tvertices("+tvertices.length+"):\t\t"+tvertices);								//0xC4				// Note, the extra data.position++ in the for loop is there 				// to skip over a byte that holds the "vertex normal index"				var _ss:Array = [];				var _a:Number, _b:Number, _c:Number;				k = 0;				for (j = 0; j <num_vertices; j++)				{					_a = tvertices[k++] / scaling;					_a = _a - tx;					_a = _a / sx;					_b = tvertices[k++] / scaling;					_b = _b - ty;					_b = _b / sy;					_c = tvertices[k++] / scaling;					_c = _c - tz;					_c = _c / sz;										data.writeByte(int(_a));					data.writeByte(int(_b));					data.writeByte(int(_c));										data.position++;										// for debug					_ss.push(int(_a),int(_b),int(_c));				}								trace("raw("+_ss.length+"):\t\t"+_ss);			}		}        		private function writeMD2Header(data:ByteArray):void		{			//CONST//ident 			data.writeInt(844121161);						//CONST//version			data.writeInt(8);						//skinwidth 			data.writeInt(skinwidth = BitmapMaterial(material).width);						//skinheight 			data.writeInt(skinheight = BitmapMaterial(material).height);						//framesize 0x34(52), 0x44(68) 			//vertnum = model.framelist[1].vlist.count			//framesize = 40+(4*vertnum)			// tri = 52, tri2 = 64, plane = 56, cube = 72			num_vertices = mesh._vertices.length/3			data.writeInt(framesize = 40+4*num_vertices);						//TODO:get from mat lib			//num_skins 			data.writeInt(num_skins = 1);						//num_vertices 			data.writeInt(num_vertices);						//num_st /* number of texture coordinates */			data.writeInt(num_st = mesh.faces.length*3);						//num_tris 			data.writeInt(num_tris = mesh.faces.length);						//CONST//num_glcmds 			data.writeInt(num_glcmds = 0);						//num_frames 			data.writeInt(num_frames = 1);						//CONST//offset_skins = headersize			data.writeInt(offset_skins = 0x44);						//offset_st /* offset texture coordinate data */			//offset_st = offsetskins + (skinnum*64)			//0x84 			data.writeInt(offset_st = offset_skins + num_skins*64);						//offsettris = offset_st + (texnum*texsize)			// 0x90, 144			data.writeInt(offset_tris = offset_st + num_st*4);						// offsetframes = offsettris + (trinum*trisize)			// 0x9C, cube = 0x1A4 (420)			data.writeInt(offset_frames = offset_tris + num_tris*12);						// offsetgl = offsetframes + (framenum*framesize)			// framesize = 40+(4*vertnum)			// 0xD0			data.writeInt(offset_glcmds = offset_frames + num_frames*framesize);						// offsetend = offsetgl + (glnum*4)			// 0xFC			data.writeInt(offset_end = offset_glcmds + num_glcmds*4);		}		public function export(object3D:Object3D = null):ByteArray		{			//convert(object3D);			exportData();			return md2;		}				public function MD2Builder()		{			// TODO : multi mesh			super();                        ///binary = true;		}	}}