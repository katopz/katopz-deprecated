package away3dlite.loaders{	import __AS3__.vec.Vector;		import away3dlite.animators.*;	import away3dlite.animators.frames.Frame;	import away3dlite.arcane;	import away3dlite.containers.ObjectContainer3D;	import away3dlite.core.base.Mesh;	import away3dlite.core.base.Object3D;	import away3dlite.materials.BitmapMaterial;		import flash.utils.ByteArray;	import flash.utils.Endian;	use namespace arcane;	public class MD2Builder extends MD2	{        /*        private var md2:ByteArray;        private var ident:int;        private var version:int;        private var skinwidth:int;        private var skinheight:int;        private var framesize:int;        private var num_skins:int;        private var num_vertices:int;        private var num_st:int;        private var num_tris:int;        private var num_glcmds:int;        private var num_frames:int;        private var offset_skins:int;        private var offset_st:int;        private var offset_tris:int;        private var offset_frames:int;        private var offset_glcmds:int;        private var offset_end:int;    	private var mesh:MovieMesh;    	    	private var _outMesh:MovieMesh;    			// temporary use		private var _indices:Vector.<int> = new Vector.<int>();		private var _vertices:Vector.<Number> = new Vector.<Number>();				private var minX:Number = Infinity, maxX:Number = -Infinity, minY:Number = Infinity, maxY:Number = -Infinity, minZ:Number = Infinity, maxZ:Number = -Infinity;		*/				public static var _outMesh:MovieMesh;				/** @private */		public function convert(object3D:Object3D, animationName:String = "default"):void		{			_outMesh = new MovieMesh();						_outMesh._vertices.fixed = false;			_outMesh._uvtData.fixed = false;			_outMesh._indices.fixed = false;			_outMesh._faceLengths.fixed = false;			if(object3D.animationLibrary)			{				var _bonesAnimator:BonesAnimator = object3D.animationLibrary.getAnimation(animationName).animation as BonesAnimator;				_bonesAnimator.update(0);					var _inputMesh:Mesh = ObjectContainer3D(object3D).children[0] as Mesh;					_outMesh._vertices = _inputMesh._vertices.concat();				_outMesh._uvtData = _inputMesh._uvtData.concat();				_outMesh._indices = _inputMesh._indices.concat();				_outMesh._faceLengths = _inputMesh._faceLengths.concat();								convertFrames(_inputMesh, _bonesAnimator);					// material				if (_inputMesh.material)					_outMesh.material = _inputMesh.material;					// build				_outMesh.buildFaces();			}else{				_outMesh = object3D as MovieMesh;			}		}				/** @private */		private function convertFrames(_inputMesh:Mesh, _bonesAnimator:BonesAnimator):void		{			var _length:Number = _bonesAnimator.length;			var _step:Number = _outMesh.fps/1000;			var i:Number;			for (i = 0; i < _length; i+=_step)			{				_bonesAnimator.update(i);				var frame:Frame = new Frame("walk__0", _inputMesh._vertices.concat());				_outMesh.addFrame(frame);			}		}				arcane override function prepareData(data:*):void		{			super.prepareData(data);			//md2 = data as ByteArray;		}				/** @private */        private function exportData():void        {        	//md2 = new ByteArray();			var a:int, b:int, c:int, ta:int, tb:int, tc:int, i1:int, i2:int, i3:int;			var i:int, uvs:Array = [];						md2.position = 0;        	        	// Make sure to have this in Little Endian or you will hate you life.        	md2.endian = Endian.LITTLE_ENDIAN;        	        	// Write the header to make it valid MD2 file        	writeMD2Header(md2);        	        	// UV coordinates        	num_st = 3;        	skinwidth = BitmapMaterial(material).width;        	skinheight = BitmapMaterial(material).height;        	        	//TODO:tri2        	/* offset texture coordinate data */        	md2.position = offset_st = 132;        	        	var _uvtData:Vector.<Number> = mesh._uvtData;        	        	for (i = 0; i < _uvtData.length; i+=3)			{				md2.writeShort(skinwidth*_uvtData[i + 0]);				md2.writeShort(skinheight*_uvtData[i + 1]);			}						// faces			var _indices:Vector.<int> = mesh._indices;			num_tris = mesh._vertices.length/9;						md2.position = offset_tris = 144;						ta = 0;			tb = 1;			tc = 2;						for (i = 0; i < num_tris; i++) 			{				i1 = i*3 + 0;				i2 = i*3 + 1;				i3 = i*3 + 2;								//collect indices				a = _indices[i1]				b = _indices[i2]				c = _indices[i3]								md2.writeShort(a);				md2.writeShort(b);				md2.writeShort(c);								//collect uvData 				uvs[ta*2 + 0] = _uvtData[i1*3 + 0];				uvs[ta*2 + 1] = _uvtData[i1*3 + 1];								uvs[tb*2 + 0] = _uvtData[i2*3 + 0];				uvs[tb*2 + 1] = _uvtData[i2*3 + 1];								uvs[tc*2 + 0] = _uvtData[i3*3 + 0];				uvs[tc*2 + 1] = _uvtData[i3*3 + 1];								// where's ta,tb,tc cam from huh!?				md2.writeShort(ta);				md2.writeShort(tb);				md2.writeShort(tc);								trace(ta, tb, tc);								ta += 3;				tb += 3;				tc += 3;			}						md2.position = offset_frames = 0x9C;			writeFrames(md2);						//mesh.buildFaces();        }                private function writeFrames(data:ByteArray):void		{			var sx:Number, sy:Number, sz:Number;			var tx:Number, ty:Number, tz:Number;			var fvertices:Vector.<Number>, frame:Frame;			var tvertices:Vector.<Number>;			var i:int, j:int, k:int, char:int;						//TODO			num_frames = 1;						for (i = 0; i < num_frames; i++) 			{				frame = mesh.frames[i];								tvertices = new Vector.<Number>(num_tris*9, true);				fvertices = frame.vertices; //new Vector.<Number>(num_tris*9, true);								//0.04723247513175011,0.047226324677467346,-1.4603789011413681e-10,				//-12.00953197479248,-0.03354215249419212,-3.233832993054797e-11								data.writeFloat(sx=0.04723247513175011);				data.writeFloat(sy=0.047226324677467346);				data.writeFloat(sz=-1.4603789011413681e-10);				data.writeFloat(tx=-12.00953197479248);				data.writeFloat(ty=-0.03354215249419212);				data.writeFloat(tz=-3.233832993054797e-11);								//write frame name				data.writeUTFBytes("Frame000");								//skip?				data.position = 0xC4								// read vertices				for (j = 0; j < num_tris*3; j++) 				{					tvertices[_indices[j]*3 + 0] = fvertices[j*3 + 0];					tvertices[_indices[j]*3 + 1] = fvertices[j*3 + 1];					tvertices[_indices[j]*3 + 2] = fvertices[j*3 + 2];				}								//0xC4				// Note, the extra data.position++ in the for loop is there 				// to skip over a byte that holds the "vertex normal index"				var _ss:Array = [];				var _a:Number, _b:Number, _c:Number;				k = 0;				for (j = 0; j < num_vertices; j++)				{					_a = tvertices[k++] / scaling;					_a = _a - tx;					_a = _a / sx;					_b = tvertices[k++] / scaling;					_b = _b - ty;					_b = _b / sy;					_c = tvertices[k++] / scaling;					_c = _c - tz;					_c = _c / sz;										data.writeByte(_a);					data.writeByte(_b);					data.writeByte(_c);										data.position++;										// for debug					_ss.push(_a,_b,_c);				}								trace("write:"+_ss);			}		}        		private function writeMD2Header(data:ByteArray):void		{			//ident 			data.writeInt(844121161);			//version			data.writeInt(8);			//skinwidth 			data.writeInt(128);			//skinheight 			data.writeInt(128);			//framesize 			data.writeInt(52);			//num_skins 			data.writeInt(1);			//num_vertices 			data.writeInt(3);			//num_st /* number of texture coordinates */			data.writeInt(3);			//num_tris 			data.writeInt(1);			//num_glcmds 			data.writeInt(208);			//num_frames 			data.writeInt(1);			//offset_skins 			data.writeInt(68);			//offset_st /* offset texture coordinate data */			data.writeInt(132);			/*			offset_tris = data.writeInt();			offset_frames = data.writeInt();			offset_glcmds = data.writeInt();			offset_end = data.writeInt();			*/		}		public function export(object3D:Object3D = null):ByteArray		{			//convert(object3D);			exportData();			return md2;		}				public function MD2Builder()		{			// TODO : multi mesh			super();                        ///binary = true;		}	}}